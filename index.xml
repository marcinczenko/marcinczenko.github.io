<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>marcin.czenko</title>
    <link>https://marcinczenko.github.io/index.xml</link>
    <description>Recent content on marcin.czenko</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 23 Mar 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://marcinczenko.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>aurelia-redux</title>
      <link>https://marcinczenko.github.io/post/aurelia-redux/</link>
      <pubDate>Thu, 23 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://marcinczenko.github.io/post/aurelia-redux/</guid>
      <description>

&lt;p&gt;This is a demo project showing how to integrate redux and rxjs with aurelia in a &lt;a href=&#34;https://github.com/reactjs/react-redux&#34;&gt;react-redux&lt;/a&gt; way.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The complete source code can be find at &lt;a href=&#34;https://github.com/marcinczenko/aurelia-redux&#34;&gt;https://github.com/marcinczenko/aurelia-redux&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;how-to-run&#34;&gt;How to run&lt;/h3&gt;

&lt;p&gt;After cloning run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ au run --watch
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;One of the patterns that helps keeping our apps clear and maintainable as they grow is the Data-Down, Actions-Up pattern. It puts clear constraints on the data flow between parent and child components: the data that a child component needs to render its view (or to do its job in general) are provided by its parent and the only way to change the data is via so called actions. This is in contrast to two-way data bindings, where data changes that affect the model are immediately propagated to the corresponding template, and conversely, any changes made in the UI are promptly reflected in the underlying model. Magic! This may seem convenient for unexperienced developer at first, but when employed in larger scale and more complex applications, two-way data binding can often become more of a headache than a blessing ( finding out where to mutate your data, tracing the source of mutated data. etc). Even in smaller applications, the Data-Down, Actions-Up brings important benefits - it makes the code easy to read and reason about, which drastically lowers the probability of make a mistake.
The Data-Down, Actions-Up pattern is well known to (originates from?) the Ember and React communities, but more and more developers are appreciating its clean and easy to follow principles.&lt;/p&gt;

&lt;h3 id=&#34;redux&#34;&gt;Redux&lt;/h3&gt;

&lt;p&gt;We could realise data-down, actions-up pattern using combination of Aurelia&amp;rsquo;s native one-way data bindings and EventAggregator Events, but to achieve a true uni-directional data-flow we will use Redux. From the Redux documentation:&lt;/p&gt;

&lt;p&gt;Redux is a predictable state container for JavaScript apps.
(&amp;hellip;)
It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. On top of that, it provides a great developer experience, such as live code editing combined with a time traveling debugger.
You can use Redux together with React, or with any other view library.&lt;/p&gt;

&lt;p&gt;Redux achieves its goals by observing the three fundamental principles:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://redux.js.org/docs/introduction/ThreePrinciples.html#single-source-of-truth&#34;&gt;Single source of truth&lt;/a&gt;. &lt;br /&gt;
The state of your whole application is stored in an object tree within a single store.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://redux.js.org/docs/introduction/ThreePrinciples.html#state-is-read-only&#34;&gt;State is read-only&lt;/a&gt;. &lt;br /&gt;
The only way to change the state is to emit an action, an object describing what happened.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://redux.js.org/docs/introduction/ThreePrinciples.html#changes-are-made-with-pure-functions&#34;&gt;Changes are made with pure functions&lt;/a&gt;. &lt;br /&gt;
To specify how the state tree is transformed by actions, you write pure reducers.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Learn Redux from its author Dan Abramov in a video course consisting of 30 videos: &lt;a href=&#34;https://egghead.io/series/getting-started-with-redux&#34;&gt;Getting Started with Redux&lt;/a&gt;.
Redux integrates well with most of the frameworks, but there is a healthy pattern around that helps making it smooth.&lt;/p&gt;

&lt;h3 id=&#34;application-state-container-components-and-presentational-components&#34;&gt;Application State, Container Components, and Presentational Components&lt;/h3&gt;

&lt;p&gt;I will use a short paragraph from the &lt;a href=&#34;http://www.ember-redux.com/ddau/&#34;&gt;ember-redux&lt;/a&gt; community:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The core concept is that we should separate the responsibility of components into 2 groups. The first group is given the label Container Components and they act like the “backend of the frontend” in a way. They will be “connected” to the datasource and delegate to other components for any html that is rendered on the page. The second group is given the label Presentational Components and as you can probability guess the only job they have is to render html given some object/data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The data source is the application state - the one and only one source of truth for the whole app.
The picture below illustrates the idea:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dl.dropboxusercontent.com/u/76613492/blogs/hugo/images/DataDown-ActionsUp.png&#34; alt=&#34;data-down, actions-up&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;using-redux-with-aurelia&#34;&gt;Using Redux with Aurelia&lt;/h3&gt;

&lt;p&gt;Our way of integrating Redux with Aurelia is inspired by &lt;a href=&#34;https://github.com/reactjs/react-redux&#34;&gt;react-redux&lt;/a&gt; - the official React bindings for Redux. react-redux takes the burden of creating the container components away using their &lt;a href=&#34;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&#34;&gt;connect&lt;/a&gt; function, here we will try to do something similar - in Aurelia world having React on the horizon.&lt;/p&gt;

&lt;p&gt;We need to provide three things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Passing a subset of an application state (possibly mapped to some other object) from parent to child component. We call this subset &lt;em&gt;props&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Making the props dynamic - if the relevant subset of the state changes, so should the related props.&lt;/li&gt;
&lt;li&gt;Dispatching actions up from child to parent (or presentational component to a container component) also happens via functions passed from parent to the child via &lt;em&gt;props&lt;/em&gt;. We need to facilitate that as well.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;container-components&#34;&gt;Container components&lt;/h3&gt;

&lt;p&gt;As depicted in the picture above, container components are the only one that have access to the application state. A pure container component would have the following structure:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TodoListContainer.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import {inject} from &#39;aurelia-framework&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;import {AureliaProps} from &amp;lsquo;services/props/AureliaProps&amp;rsquo;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TodoListContainerProps extends AureliaProps {
  mapStateToProps(state) {
    return {
      todos: state.todos
    };
  }

  mapDispatchToProps() {
    return {
      todoToggle: (id) =&amp;gt; {
         this.applicationStateCoordinator.dispatch(this.actionCreators.todoToggle(id));
      },
      todoAdd: (id, text) =&amp;gt; {
        this.applicationStateCoordinator.dispatch(this.actionCreators.todoAdd(id, text));
      }
    };
  }
}

@inject(TodoListContainerProps)
export class TodoListContainer {
  constructor(props) {
    this.props = props;
  }

  detached() {
    this.props.unsubscribe();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;TodoListContainer.html&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;require from=&amp;quot;./TodoList&amp;quot;&amp;gt;&amp;lt;/require&amp;gt;
  &amp;lt;todo-list props.bind=&amp;quot;props&amp;quot;&amp;gt;&amp;lt;/todo-list&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We see that the container component simply wraps the presentations component &lt;code&gt;todo-list&lt;/code&gt; and provides it with props via one-way data binding. The &lt;code&gt;todo-list&lt;/code&gt; presentation component does not have to do much to access the props from its parent:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ToDoList.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export class TodoList {
  @bindable props;

  @observable todoText;

  constructor() {
    this.styles = styles;
    this.buttonDisabled = &#39;disabled&#39;;
  }

  propsChanged() {
    console.log(&#39;propsChanged=&#39;, this.props);
  }

  todoTextChanged() {
    if (this.todoText.trim().length === 0) {
      this.buttonDisabled = &#39;disabled&#39;;
    } else {
      this.buttonDisabled = &#39;&#39;;
    }
  }

  addTodo() {
    this.props.todoAdd(this.props.todos.length, this.todoText);
    this.todoText = &#39;&#39;;
  }
}

const styles = {
  container: {
    margin: &#39;10px&#39;,
    padding: 0,
    width: &#39;600px&#39;
  },

  todoList: {
    display: &#39;flex&#39;,
    &#39;flex-flow&#39;: &#39;column nowrap&#39;
  },

  inputGroup: {
    display: &#39;flex&#39;,
    margin: &#39;10px 0&#39;
  },

  button: {
    &#39;margin-left&#39;: &#39;15px&#39;,
    &#39;padding&#39;: &#39;10px&#39;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ToDoList.html&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;require from=&amp;quot;components/todo/Todo&amp;quot;&amp;gt;&amp;lt;/require&amp;gt;

  &amp;lt;div style.bind=&amp;quot;styles.container&amp;quot;&amp;gt;
    &amp;lt;h2&amp;gt;Todo list:&amp;lt;/h2&amp;gt;
    &amp;lt;div if.bind=&amp;quot;!props.todos || props.todos.length === 0&amp;quot;&amp;gt;
      Please add some todos and have fun!
    &amp;lt;/div&amp;gt;
    &amp;lt;div style.bind=&amp;quot;styles.todoList&amp;quot; repeat.for=&amp;quot;todo of props.todos&amp;quot;&amp;gt;
      &amp;lt;todo id.bind=&amp;quot;todo.id&amp;quot;
            text.bind=&amp;quot;todo.text&amp;quot; 
            completed.bind=&amp;quot;todo.completed&amp;quot;
            toggle.bind=&amp;quot;props.todoToggle&amp;quot;&amp;gt;
      &amp;lt;/todo&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;form submit.trigger=&amp;quot;addTodo()&amp;quot;&amp;gt;
      &amp;lt;div style.bind=&amp;quot;styles.inputGroup&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; value.bind=&amp;quot;todoText&amp;quot;&amp;gt;
        &amp;lt;button style.bind=&amp;quot;styles.button&amp;quot; disabled.bind=&amp;quot;buttonDisabled&amp;quot; type=&amp;quot;submit&amp;quot;&amp;gt;Add Todo&amp;lt;/button&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/form&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We see that the relevant data is passed down to the children &lt;code&gt;todo&lt;/code&gt; components together with actionable &lt;code&gt;todoToggle&lt;/code&gt; function. Additionally, the &lt;code&gt;TodoList&lt;/code&gt; component provides a form with an edit field and a button that allow us to add more todo items.
Important to note here, that we are not trying to be dogmatic about two-way bindings - they are usually fine in form controls where data need to be passed from the view to the view model. This is exactly what we do with the &lt;code&gt;todoText&lt;/code&gt; that is bound to the form&amp;rsquo;s input value in the &lt;code&gt;TodoList&lt;/code&gt; component. Notice though that this two-way binding stops at the component level and does not propagate further. We also do not use two way bindings with custom components: two-way binding is only ok between view controls and view model.
Finally, we have our &lt;code&gt;todo&lt;/code&gt; component:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ToDo.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { bindable } from &#39;aurelia-framework&#39;;

export class Todo {
  @bindable id;
  @bindable text;
  @bindable completed;
  @bindable toggle;

  constructor() {
    this.styles = styles;
  }

  toggleCompleted() {
    this.toggle(this.id);
  }

  completedChanged() {
    this.updateStyle();
  }

  updateStyle() {
    if (this.completed) {
      this.styles = {...styles, todo: {...styles.todoCompleted} };
    } else {
      this.styles = {...styles, todo: {...styles.todoNotCompleted} };
    }
  }
}

const styles = {
  container: {
    display: &#39;flex&#39;,
    &#39;flex-flow&#39;: &#39;row nowrap&#39;,
    &#39;align-items&#39;: &#39;center&#39;,
    width: &#39;100%&#39;
  },
  buttonContainer: {
    flex: 1,
    display: &#39;block&#39;,
    margin: &#39;0 10px&#39;
  },
  button: {
    padding: &#39;15px&#39;
  },
  todoCompleted: {
    flex: 1,
    &#39;text-decoration&#39;: &#39;line-through&#39;
  },
  todoNotCompleted: {
    flex: 1,
    &#39;text-decoration&#39;: &#39;none&#39;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ToDo.html&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;template&gt;
      &lt;div&gt;
        &lt;p style.bind=&#34;styles.todo&#34;&gt;${this.text}&lt;/p&gt;
        &lt;button click.delegate=&#34;toggleCompleted()&#34;&gt;Toggle Completed&lt;/button&gt;
      &lt;/div&gt;
    &lt;/template&gt;&lt;/p&gt;

&lt;p&gt;When the user clicks on the &lt;em&gt;Toggle Completed&lt;/em&gt; button the action is triggered via the &lt;code&gt;toggle&lt;/code&gt; function that was provided from the parent. The &lt;code&gt;Todo&lt;/code&gt; item does not maintain its internal state - it is driven by the state changes on the parent. Thanks to this, &lt;code&gt;Todo&lt;/code&gt; is simple to reason about. In general, one-way data flow makes reasoning about the system easier and less error prone, even though it may give impression of more boilerplate code.&lt;/p&gt;

&lt;h3 id=&#34;how-does-it-work&#34;&gt;How does it work?&lt;/h3&gt;

&lt;p&gt;If you read the code above, you notice that there is no single mention of Redux. The container component - &lt;code&gt;TodoListContainer&lt;/code&gt; - is provided with convenient &lt;code&gt;props&lt;/code&gt; object (via native Aurelia dependency injection mechanism) that already contains only the subset of the actual application state:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TodoListContainerProps extends AureliaProps {
  mapStateToProps(state) {
    return {
      todos: state.todos
    };
  }

  mapDispatchToProps() {
    return {
      todoToggle: (id) =&amp;gt; {
        this.dispatch(this.actionCreators.todoToggle(id));
      },
      todoAdd: (id, text) =&amp;gt; {
        this.dispatch(this.actionCreators.todoAdd(id, text));
      }
    };
  }
}

@inject(TodoListContainerProps)
export class TodoListContainer {
  constructor(props) {
    this.props = props;
  }

  detached() {
    this.props.unsubscribe();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to declare which part of the state our container component is interested in, all what is needed is a class with two required methods (inspired by &lt;a href=&#34;https://github.com/reactjs/react-redux&#34;&gt;react-redux&lt;/a&gt;): &lt;code&gt;mapStateToProps&lt;/code&gt; and &lt;code&gt;mapDispatchToProps&lt;/code&gt;. First represents the &lt;em&gt;data down&lt;/em&gt; pattern, the second &lt;em&gt;actions up&lt;/em&gt;. The &lt;em&gt;Props&lt;/em&gt; class (as we will call it from now on), extends the AureliaProps class where the magic happens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import {inject} from &#39;aurelia-framework&#39;;

import {ApplicationStateCoordinator} from &#39;services/state-management/ApplicationStateCoordinator&#39;;
import {ActionCreators} from &#39;application-state/ActionCreators&#39;;

@inject(ApplicationStateCoordinator, ActionCreators)
export class AureliaProps {
  constructor(applicationStateCoordinator, actionCreators) {
    this.applicationStateCoordinator = applicationStateCoordinator;
    this.actionCreators = actionCreators;
    this.observable = this.applicationStateCoordinator.observable((state) =&amp;gt; {
        return this.mapStateToProps(state);
    });
    this.subscription = this.observable.subscribe((props) =&amp;gt; {
      Object.assign(this, props);
    });
    Object.assign(this, this.mapDispatchToProps());
  }

  dispatch(action) {
    this.applicationStateCoordinator.dispatch(action);
  }

  unsubscribe() {
    this.subscription.unsubscribe();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The AureliaProps class does two things:
1. It provides the &lt;code&gt;ApplicationStateCoordinator&lt;/code&gt; and &lt;code&gt;ActionCreators&lt;/code&gt; instances to the receiver. Thanks to this &lt;code&gt;TodoListContainerProps&lt;/code&gt; class can conveniently dispatch the actions. The actions themselves are conveniently created with &lt;code&gt;ActionCreators&lt;/code&gt; that hide the details of the internal action format.
2. It makes props object dynamically changing every time the relevant part of the state changes. This is the job of the &lt;code&gt;ApplicationStateCoordinator&lt;/code&gt; that provides &lt;em&gt;rxjs&lt;/em&gt; observable that will fire everytime the selection of the state specified by the &lt;code&gt;mapStateToProps&lt;/code&gt; that we described above.&lt;/p&gt;

&lt;p&gt;Below we present the code of the &lt;code&gt;ApplicationStateCoordinator&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { createStore } from &#39;redux&#39;;
import Rx from &#39;@reactivex/rxjs&#39;;

import { applicationReducer } from &#39;application-state/Reducers&#39;;

export class ApplicationStateCoordinator {

  constructor() {
    this.reduxStore = createStore(applicationReducer);
  }

  observable(select) {
    return Rx.Observable.create((observer) =&amp;gt; {
      let currentState;
      let dispose = this.reduxStore.subscribe(() =&amp;gt; {
        let nextState = select(this.reduxStore.getState());
        if (nextState !== currentState) {
          observer.next(nextState);
        }
      });
      observer.next(select(this.reduxStore.getState()));
      return dispose;
    });
  }

  dispatch(action) {
    this.reduxStore.dispatch(action);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;observable&lt;/code&gt; method returns a function that will unsubscribe from following the (sub)state changes. We use it in the detached method of the container component:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;detached() {
  this.props.unsubscribe();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UIDatePicker does not respond to the first valueChanged event</title>
      <link>https://marcinczenko.github.io/post/uidatepicker-does-not-respond-to-first-valueChanged-event/</link>
      <pubDate>Wed, 25 Jan 2017 18:11:28 +0100</pubDate>
      
      <guid>https://marcinczenko.github.io/post/uidatepicker-does-not-respond-to-first-valueChanged-event/</guid>
      <description>&lt;p&gt;Time ago I found another problem that somehow resembles this one. It was about presenting a view controller from within the &lt;code&gt;tableView:didSelectRowAtIndexPath:&lt;/code&gt; and the problem was that it was taking lots of time for the new controller to actually show up. One of the workarounds turned out to be using &lt;code&gt;dispatch_async&lt;/code&gt; on the main queue. The same worked for me in this case.&lt;/p&gt;

&lt;p&gt;In my &lt;code&gt;viewDidLoad&lt;/code&gt;, I asynchronously dispatched the picker setup code on the main queue and, in my case, it started to respond to the &lt;code&gt;valueChanged&lt;/code&gt; event even on the first pick:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DispatchQueue.main.async {
    self.pickerView.datePickerMode = .countDownTimer
    self.pickerView.minuteInterval = 5
    self.pickerView.countDownDuration = 15
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See also:
- &lt;a href=&#34;https://marcinczenko.github.io/post/presentViewController-from-didSelectRowAtIndexPath-very-slow/&#34;&gt;presentViewController from didSelectRowAtIndexPath very slow&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>presentViewController from didSelectRowAtIndexPath very slow</title>
      <link>https://marcinczenko.github.io/post/presentViewController-from-didSelectRowAtIndexPath-very-slow/</link>
      <pubDate>Tue, 26 Jul 2016 14:47:01 +0200</pubDate>
      
      <guid>https://marcinczenko.github.io/post/presentViewController-from-didSelectRowAtIndexPath-very-slow/</guid>
      <description>&lt;p&gt;And intersting behaviour can be observed when presenting a view controller from
&lt;code&gt;tableView:didSelectRowAtIndexPath:&lt;/code&gt;. It may take long seconds before the new view will be presented. This problem does not seem to be new and is already reported on &lt;a href=&#34;http://openradar.appspot.com/19563577&#34;&gt;openradar&lt;/a&gt; for &lt;em&gt;iOS8.1&lt;/em&gt;, but comments and my own tests indicate that the problem persists even in &lt;em&gt;iOS9.3.3&lt;/em&gt; (build &lt;code&gt;13G34&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Two workarounds are to be known:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Wrap the presenting of a controller in a &lt;code&gt;dispatch_async&lt;/code&gt; call on the main queue.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;[self.tableView deselectRowAtIndexPath:indexPath animated:NO];&lt;/code&gt; before presenting the view controller.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Below is an example with &lt;code&gt;dispatch_async&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_async(dispatch_get_main_queue(), ^{
        UIAlertController* alert = [UIAlertController 
               alertControllerWithTitle:@&amp;quot;Message&amp;quot;
                                message:@&amp;quot;I have shown up immediately :)&amp;quot;
                         preferredStyle:UIAlertControllerStyleAlert];

        UIAlertAction* defaultAction = [UIAlertAction actionWithTitle:@&amp;quot;OK&amp;quot;
                                  style:UIAlertActionStyleDefault
                                handler:^(UIAlertAction * action) {}];

        [alert addAction:defaultAction];
        [self.navigationController presentViewController:alert animated:YES completion:nil];
        alert.view.tintColor = [UIColor darkGrayColor];
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;BTW: in the code above you see changing the alert&amp;rsquo;s button text color via the &lt;code&gt;tintColor&lt;/code&gt; property. It has to happen after an alert controller is presented or the setting of the caller will have no impact.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>welcome</title>
      <link>https://marcinczenko.github.io/post/welcome/</link>
      <pubDate>Sat, 16 Jul 2016 17:48:05 +0200</pubDate>
      
      <guid>https://marcinczenko.github.io/post/welcome/</guid>
      <description>

&lt;p&gt;I used to host my blog on &lt;a href=&#34;https://www.tumblr.com/&#34;&gt;Tumblr&lt;/a&gt;. Unfortunately, Tumblr does not make the editting work easy and I had countless moments of frustration when working with Markdown.
So this is why I decided for ultimate simplicity and I went for statically generated blog site hosted at github, which seems to be one of the best places in this world to host one&amp;rsquo;s engineering blog.&lt;/p&gt;

&lt;p&gt;Over next days (weeks?) my old blog from &lt;a href=&#34;http://blog.redgreenrefactor.eu&#34;&gt;http://blog.redgreenrefactor.eu&lt;/a&gt; will be moved over here.&lt;/p&gt;

&lt;p&gt;To make everything easy to work with, I am using &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt; - the best static page generator I saw so far!&lt;/p&gt;

&lt;p&gt;This post is more about testing just a couple of the formattings that I consider must-haves.&lt;/p&gt;

&lt;h2 id=&#34;header&#34;&gt;Header&lt;/h2&gt;

&lt;p&gt;Text with &lt;em&gt;italics&lt;/em&gt; and &lt;strong&gt;bold&lt;/strong&gt;, and a link &lt;a href=&#34;https://github.com/marcinczenko&#34;&gt;marcinczenko&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A bit of inline source code &lt;code&gt;brew install hugo&lt;/code&gt;, and a code block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let array = [1,2,3,4,5]

array.map({$0*$0})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice! But can it handle images?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://marcinczenko.github.io/img/welcome/commodore64.jpg&#34; alt=&#34;Commodore64&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>distributed persistance with swift and coredata</title>
      <link>https://marcinczenko.github.io/post/distributed-persistance-with-swift-and-coredata/</link>
      <pubDate>Thu, 30 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://marcinczenko.github.io/post/distributed-persistance-with-swift-and-coredata/</guid>
      <description>

&lt;p&gt;Component-based architectures give us high level of isolation and independence of the underlying components, but at the same time exibits potential risk of duplication. How would a component-based architecture work for iOS apps, especially when persistance is the key. Let&amp;rsquo;s experiment&amp;hellip;&lt;/p&gt;

&lt;p&gt;Let me create a framerwork in which I will have seprate components. I want my components to be possibly independent from each other, but at the same time I want to limit duplication. And trying to push the idea to the extreme, if a component needs to store anything in CoreData (we will use CoreData in this example, but you can easily abstract it away and use different storage options), I let the component to have its own model and its own sqlite file - in other words rather than sharing one CoreData stack among all the components, each component maintains its own instance of the CoreData stack. I am not sure how robust this architecture would be, and how well will it scale in terms of perfomance, but the possibility of throwing a component away at any moment without worrying about other component is very appealing and may be a good option in some applications.&lt;/p&gt;

&lt;p&gt;Every type that is supposed to be stored in CoreData has its domain level equivalent. CoreData&amp;rsquo;s managed objects, actually everything that&amp;rsquo;s related to CoreData can only occur in the CoreData stack  itself and in a wrapper that encapsulates low-level CoreData operations and translates between managed objects and the corresponding domain types.&lt;/p&gt;

&lt;p&gt;Above the CoreData wrapper, there is a &lt;em&gt;data store&lt;/em&gt; that provides high level persistance interface and enforces data integrity.&lt;/p&gt;

&lt;p&gt;The CoreData wrapper and the data store provide a uniform set of operations that can be reused among components. Each component will have its own instances of the CoreData stack, the CoreData wrapper, and a data store, but I want them all to share the same source code.&lt;/p&gt;

&lt;h3 id=&#34;domain-objects&#34;&gt;Domain objects&lt;/h3&gt;

&lt;p&gt;All our domain objects have to conform to the following protocol:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol EPQuantity {
    associatedtype EPQuantityType
    func getValue() -&amp;gt; EQQuantityType
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;associatedtype&lt;/code&gt; is a placeholder for the actuall type that will be provided by the type conforming to the protocol. Our protocol requires that a type conforming to it must have a method &lt;code&gt;getValue&lt;/code&gt; returing a value of a type that is specific to the given domain object. This makes the protocol a good candidate for many types as long they can provide a value.&lt;/p&gt;

&lt;p&gt;Now, lets take two example domain level value types conforming to the &lt;code&gt;EPQuantity&lt;/code&gt; protocol:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct EPAcceleration: EPQuantity, CustomStringConvertible {
    let acceleration: Double

    var description: String {
        return &amp;quot;EPAcceleration(acceleration: \(acceleration))&amp;quot;
    }

    func getValue() -&amp;gt; Double {
        return acceleration
    }
}

struct EPSpeed: EPQuantity, CustomStringConvertible {
    let speed: Int

    var description: String {
        return &amp;quot;EPSpeed(speed: \(speed))&amp;quot;
    }

    func getValue() -&amp;gt; Int {
        return speed
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What is important to see is that both types represents quantities of different types: we have an &lt;code&gt;Int&lt;/code&gt; for the speed, but &lt;code&gt;Double&lt;/code&gt; for acceleration.&lt;/p&gt;

&lt;h3 id=&#34;data-store&#34;&gt;Data store&lt;/h3&gt;

&lt;p&gt;Now we want to be able to store the domain objects in a data store. We may be tempted to start with the following implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class EPDataStore {
    func store(item: EPQuantity)
    func getAll() -&amp;gt; EPQuantity
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The compiler, however, will give us the following compile-time error: &lt;em&gt;Protocol &amp;lsquo;EPQuantity&amp;rsquo; can only be used as a generic constraint because it has Self or associated type requirements&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;To fix this problem we can either do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class EPDataStore {
    func store&amp;lt;T: EPQuantity&amp;gt;(item: T) {

    }

    func getAll&amp;lt;T: EPQuantity&amp;gt;() -&amp;gt; [T]? {
        return nil
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class EPDataStore&amp;lt;T: EPQuantity&amp;gt; {

    func store(item: T) {

    }

    func getAll() -&amp;gt; [T]? {
        return nil
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem we may have with this implementation is that we may want to be slightly more specific about which types should be allowed to enter the store. For instance, &lt;code&gt;EPSpeed&lt;/code&gt; and &lt;code&gt;EPAcceleration&lt;/code&gt; being domain equivalent of some managed objects, will ultimately need to match the corresponding types of the attributes in the manged objects. We can immediatelly think of &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;NSTimeInterval&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;NSDate&lt;/code&gt;, &lt;code&gt;NSNumber&lt;/code&gt; and perhapes a couple of more options. For now, to support &lt;code&gt;EPSpeed&lt;/code&gt; and &lt;code&gt;EPAcceleration&lt;/code&gt;, we only need to support &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt;. How can we make the type constraint in &lt;code&gt;EPDataStore&lt;/code&gt; more specific?&lt;/p&gt;

&lt;p&gt;One way is to create another protocol and require that an instance of (a type implementing)&lt;code&gt;EPQuantity&lt;/code&gt; can be stored in our store if and only if the type returned by its &lt;code&gt;getValue&lt;/code&gt; requirement conforms to this new protocol. Let&amp;rsquo;s call this protocol &lt;code&gt;EPPersistable&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol EPPersistable {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s update &lt;code&gt;EPDataStore&lt;/code&gt; with a more specific type constraint:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class EPDataStore&amp;lt;T: EPQuantity where T.EPQuantityValueType: EPPersistable&amp;gt; {

    func store(item: T) {

    }

    func getAll() -&amp;gt; [T]? {
        return nil
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, if you try to create an instance of &lt;code&gt;DataStore&lt;/code&gt; for &lt;code&gt;EPSpeed&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let dataStore = EPDataStore&amp;lt;EPSpeed&amp;gt;()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the compliler will complain with &lt;em&gt;Type &amp;lsquo;Int&amp;rsquo; does not conform to protocol &amp;lsquo;EPPersistable&amp;rsquo;&lt;/em&gt;. We can make the error go away by using an &lt;em&gt;extenssion&lt;/em&gt; to add protocol conformance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Int: EPPersistable {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and if we want to persist instances of &lt;code&gt;EPAcceleration&lt;/code&gt;, we would also need:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Double: EPPersistable {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s nice, but let&amp;rsquo;s get back to our isolated components. Each is holding its own CoreData stack, a CoreData wrapper to translate between managed objects and domain objects, and a DataStore to handle data integrity or any other required logic. As a &lt;code&gt;DataStore&lt;/code&gt; dependency, we want the CoreData wrapper to provide a mapping between objects conforming to the &lt;code&gt;EPQuantity&lt;/code&gt; protocol and the corresponding managed objects that will land in our CoreData storage. As an example, &lt;code&gt;EPSpeed&lt;/code&gt; would be matched by the following managed object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@objc(EPSpeedCoreData)
class EPSpeedCoreData: NSManagedObject {

    // Insert code here to add functionality to your managed object subclass

}

extension EPSpeedCoreData {
    @NSManaged var speed: Int32
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, in order to be able to handle different managed objects through a common interface, we could add the following protocol:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol EPCoreDataQuantity {
    associatedtype EPCoreDataQuantityValueType
    func getValue() -&amp;gt; EPCoreDataQuantityValueType
    func setValue(value: EPCoreDataQuantityValueType)
}

extension EPSpeedCoreData:EPCoreDataQuantity {
    func getValue() -&amp;gt; Int {
        return Int(speed)
    }

    func setValue(value: Int) {
        speed = Int32(value)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, the skeleton of our universal CoreData wrapper could be defined by the following set of requirements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol EPPersistance {
    associatedtype EPQuantityType
    func write(item: EPQuantityType)
    func read() -&amp;gt; [EPQuantityType]?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and fullfilled by the following type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class EPCoreDataWrapper&amp;lt;T: EPCoreDataQuantity, U: EPQuantity where T.EPCoreDataQuantityValueType: EPPersistable, U.EPQuantityValueType: EPPersistable&amp;gt;: EPPersistance {

    func write(item: U) {

    }

    func read() -&amp;gt; [U]? {
        return nil
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And obviously, our &lt;code&gt;EPDataStore&lt;/code&gt; needs an instance of compatible CoreData wrapper, so obviously one could be tempted to try something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class EPDataStore&amp;lt;T: EPQuantity where T.EPQuantityValueType: EPPersistable&amp;gt; {

    let persistance: EPPersistance

    init(persistance: EPPersistance) {
        self.persistance = persistance
    }

    func store(item: T) {
        persistance.write(item)    
    }

    func getAll() -&amp;gt; [T]? {
        return persistance.read()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But we will get the familiar error - this time regarding &lt;code&gt;EPPersistance&lt;/code&gt;: &lt;em&gt;Protocol &amp;lsquo;EPPersiatance&amp;rsquo; can only be used as a generic constraint because it has Self or associated type requirements&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The solution to this problem is commonly known as &lt;em&gt;Type Erasure&lt;/em&gt;, a technique that I also describe shortly in my other post &lt;a href=&#34;https://marcinczenko.github.io/post/around-type-erasure-in-swift/&#34;&gt;Around Type Erasure in Swift&lt;/a&gt;. We cannot refer to &lt;code&gt;EPPersistance&lt;/code&gt; directly because it has an associated type. We need to hide this fact from the compiler by wrapping up the EPPersistance inside another type that will not exbit the limitation that &lt;code&gt;EPPersistance&lt;/code&gt; has. To achieve that, we create a type that wraps an instance conforming to the &lt;code&gt;EPPersistance&lt;/code&gt; protocol:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class EPAnyPersistance&amp;lt;T: EPQuantity where T.EPQuantityValueType: EPPersistable&amp;gt; : EPPersistance {

    let _write: T -&amp;gt; ()
    let _read: () -&amp;gt; [T]?

    init&amp;lt;BaseType: EPPersistance where BaseType.EPQuantityType == T&amp;gt;(base: BaseType) {
        _write = base.write
        _read = base.read
    }

    func write(item: T) {
        _write(item)
    }

    func read() -&amp;gt; [T]? {
        return _read()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, it is safe to add a reference to the persistance object to our data store:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class EPDataStore&amp;lt;T: EPQuantity where T.EPQuantityValueType: EPPersistable&amp;gt; {

    let persistance: EPAnyPersistance&amp;lt;T&amp;gt;

    init(persistance: EPAnyPersistance&amp;lt;T&amp;gt;) {
      self.persistance = persistance
    }

    func store(item: T) {
        persistance.write(item)
    }

    func getAll() -&amp;gt; [T]? {
        return persistance.read()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can create an instance of &lt;code&gt;EPDataStore&lt;/code&gt; for &lt;code&gt;EPSpeed&lt;/code&gt; type as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let dataStoreForSpeed = EPDataStore&amp;lt;EPSpeed&amp;gt;(persistance: EPAnyPersistance(base: EPCoreDataWrapper&amp;lt;EPSpeedCoreData, EPSpeed&amp;gt;()))

dataStoreForSpeed.store(EPSpeed(speed: 125))
dataStoreForSpeed.getAll()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Try it out in the playground:  &lt;a href=&#34;https://gist.github.com/marcinczenko/8c9bf9289d9f3a2eade4946b1e67af6e#file-experimentingwithpersistanceinswift-playground&#34;&gt;ExperimentingWithPersistanceInSwift.playground&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>around type erasure in swift</title>
      <link>https://marcinczenko.github.io/post/around-type-erasure-in-swift/</link>
      <pubDate>Sat, 25 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://marcinczenko.github.io/post/around-type-erasure-in-swift/</guid>
      <description>

&lt;p&gt;WWDC 2016 being already a past event (with lots of exiting material to watch), I&amp;rsquo;ve finally found more time to look more carefully to one of the most important programming paradims promoted in Swift: Protocol-Oriented Pragramming. &lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2015/408/&#34;&gt;Protocol-Oriented Programming in Swift&lt;/a&gt; was a great talk at WWDC 2015, where the concept was beautfully explained and demonstrated by Dave Abrahams. During this year&amp;rsquo;s WWDC 2016 we have a follow-up: &lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2016/419/&#34;&gt;Protocol and Value Oriented Programming in UIKit Apps&lt;/a&gt;, which immediatelly invites us to watch again another great session from WWDC 2015: &lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2015/414/&#34;&gt;Building Better Apps with Value Types in Swift&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The protocol-oriented programming is a powerful concept and I still need to digest it and reflect on it trying to use it in our production code. Here we will take a short look at a technique called &lt;em&gt;type erasure&lt;/em&gt;, which comes handy when dealing with generic protocols.&lt;/p&gt;

&lt;h3 id=&#34;the-problem&#34;&gt;The problem&lt;/h3&gt;

&lt;p&gt;Say you have a protocol:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol Logger {
    associatedtype LoggerItemType
    func log(item: LoggerItemType)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and you have a type that uses it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Proccess {

    let logger: Logger

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, this will fail with compile error saying: &lt;em&gt;Protocol &amp;lsquo;Logger&amp;rsquo; can only be used as a generic constraint because it has Self or associated type requirements&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;the-solution&#34;&gt;The solution&lt;/h3&gt;

&lt;p&gt;This problem can be solved by applying so called Type-Erasure technique in which we wrap the generic protocol, &lt;code&gt;Logger&lt;/code&gt; in our case), in another type conforming to the same protocol (&lt;code&gt;Logger&lt;/code&gt; again) and delegating all requirements to an internal object. Such &lt;em&gt;wrappers&lt;/em&gt; are often named &lt;code&gt;Any{Protocol}&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct AnyLogger&amp;lt;LoggerItemType&amp;gt; : Logger {

    let _log: LoggerItemType -&amp;gt; ()

    init&amp;lt;BaseType: Logger where BaseType.LoggerItemType == LoggerItemType&amp;gt;(base: BaseType) {
        _log = base.log
    }

    func log(item: LoggerItemType) {
        _log(item)
    }
}

struct IntLogger: Logger {
    func log(item: Int) {
        print(&amp;quot;IntLogger: \(item)&amp;quot;)
    }
}

struct Process&amp;lt;T&amp;gt; {

    let logger: AnyLogger&amp;lt;T&amp;gt;
}

let process = Process(logger: AnyLogger(base: IntLogger()))

process.logger.log(24) // prints &#39;24&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This solves the problem but when &lt;code&gt;Logger&lt;/code&gt; protocol has many requirements, &lt;code&gt;AnyLogger&lt;/code&gt; has to bridge all of them. Also every time you extend the &lt;code&gt;Logger&lt;/code&gt; protocol, you need to update &lt;code&gt;AnyLogger&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;We can improve this situation - at the cost of an extra indirection - by introducing a logger provider and applying type-erasure on it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol LoggerProvider {
    associatedtype LoggerType

    func get() -&amp;gt; LoggerType
}

struct AnyLoggerProvider&amp;lt;LoggerType&amp;gt;: LoggerProvider {
    let _get: () -&amp;gt; LoggerType

    init&amp;lt;BaseType: LoggerProvider where BaseType.LoggerType == LoggerType&amp;gt;(base: BaseType) {
        _get = base.get
    }

    func get() -&amp;gt; LoggerType {
        return _get()
    }
}

struct IntLoggerProvider: LoggerProvider {

    let intLogger: IntLogger

    func get() -&amp;gt; IntLogger {
        return intLogger
    }
}

struct Process&amp;lt;T&amp;gt; {
    let loggerProvider: AnyLoggerProvider&amp;lt;T&amp;gt;
}

let process = Process(loggerProvider: AnyLoggerProvider(base: IntLoggerProvider(intLogger: IntLogger())))

process.loggerProvider.get().log(24)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We see that, now we got one extra intermediate call, but we do not have to duplicate the &lt;code&gt;Logger&lt;/code&gt; requirements in the wrapper.&lt;/p&gt;

&lt;p&gt;Get the playground here: &lt;a href=&#34;https://gist.github.com/marcinczenko/d448780afaa499ba683d5160b9aae1d3#file-aroundtypeerasureinswift-playground&#34;&gt;AroundTypeErasureInSwift.playground&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;further-reading&#34;&gt;Further Reading&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://robnapier.net/erasure&#34;&gt;A Little Respect for AnySequence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/a/34584464/1272679&#34;&gt;StackOverflow. Anwer to question: How to use generic protocol as a variable type?&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>string conversions in swift</title>
      <link>https://marcinczenko.github.io/post/string-conversions-in-swift/</link>
      <pubDate>Fri, 20 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://marcinczenko.github.io/post/string-conversions-in-swift/</guid>
      <description>&lt;p&gt;Say you have your own custom class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyClass {
  let counter: Int

  init(withCounter: Int) {
          self.counter = withCounter
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, you want it to be convertible to &lt;code&gt;String&lt;/code&gt;. One way of doing it is to create an extension to the &lt;code&gt;String&lt;/code&gt; class itself like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension String {
  init(_ myClass: MyClass) {
    self = &amp;quot;{ counter: \(myClass.counter) }&amp;quot; 
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will let you do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let str = String(MyClass(withCounter:25)) 
// str is &amp;quot;{ counter: 25 }&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This may seem to be sufficient in many cases, but it does not seem to be truly the &lt;em&gt;Swift&lt;/em&gt; way. I realised this when working with testing framework (Nimble) and I realised that having just &lt;code&gt;String&lt;/code&gt; extension does not make Nimble to produce correct string descriptions of my class instances when testing. In particular, and you can test it easily in the playground, this will not work as expected:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let str2 = &amp;quot;\(MyClass(withCounter:25))&amp;quot; 
// str2 is &amp;quot;MyClass&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the string interpolation to work as expected in this case, you would rather have to do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let str3 = &amp;quot;\(String(MyClass(withCounter:25)))&amp;quot; 
// str3 is &amp;quot;{ counter: 25 }&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is not how you want to use string interpolation though.&lt;/p&gt;

&lt;p&gt;This &lt;a href=&#34;http://vperi.com/2014/06/04/textual-representation-for-classes-in-swift/&#34;&gt;blog&lt;/a&gt; describes how this is supposed to be done correctly in Swift 1 (still with lots of pain), and &lt;a href=&#34;http://vperi.com/2015/09/19/textual-representation-for-classes-swift/&#34;&gt;here&lt;/a&gt; is the updated version for Swift 2.&lt;/p&gt;

&lt;p&gt;To summarise, this is how you can extend &lt;code&gt;MyClass&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyClass: CustomStringConvertible {
  let counter: Int

  var description: String {
      return &amp;quot;{ counter: \(self.counter) }&amp;quot;
    }

    init(withCounter: Int) {
      self.counter = withCounter
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, the string interpolation should work as expected.
You can download the gist playground file &lt;a href=&#34;https://gist.github.com/marcinczenko/f7d6dd3fbeb02dc1245d&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>using swift frameworks from objective-c target</title>
      <link>https://marcinczenko.github.io/post/using-swift-frameworks-from-objective-c-target/</link>
      <pubDate>Sun, 17 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://marcinczenko.github.io/post/using-swift-frameworks-from-objective-c-target/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;The code in this post was tested with Xcode Version 7.2 (7C68).&lt;/p&gt;

&lt;p&gt;The accompanying source code can be found at &lt;a href=&#34;https://github.com/marcinczenko/UsingSwiftFrameworksFromObjectiveC&#34;&gt;github.com/marcinczenko/UsingSwiftFrameworksFromObjectiveC&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When working with legacy iOS products it may happens that you need to integrate with main application target that
contains only Objective-C code. You want to take advantage of Swift but you want this nicely separated from the old
legacy code. Creating a framework that will contain your Swift code is the answer.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;There is no something like a Swift framework. A framework can include both Objective-C and Swift code. In this short post we focus on a framework containing only Swift code.&lt;/p&gt;

&lt;p&gt;If you want to share your Swift code, a framework is necessary. You can&amp;rsquo;t just use a static library as they do not support Swift code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The following steps describe the whole process of creating a framework and adding it to an Objective-C-only target.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you want to follow with the source code from &lt;a href=&#34;https://github.com/marcinczenko/UsingSwiftFrameworksFromObjectiveC&#34;&gt;github.com/marcinczenko/UsingSwiftFrameworksFromObjectiveC&lt;/a&gt; please clone the repository and checkout the very first commit with comment &lt;code&gt;Initial commit.&lt;/code&gt; (commit 73e8dde) and then follow the steps. The last commit corresponds to the final state.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;step-1-add-a-taget&#34;&gt;Step 1 - add a taget&lt;/h3&gt;

&lt;p&gt;Select your project in the Project Navigator and create a new target:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dl.dropboxusercontent.com/u/76613492/tumblr/images/UsingSwiftFrameworksFromObjectiveC/CreateTarget.png&#34; alt=&#34;CreateNewTarget&#34; /&gt;&lt;/p&gt;

&lt;p&gt;and name it &lt;code&gt;ExampleSwiftFramework&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dl.dropboxusercontent.com/u/76613492/tumblr/images/UsingSwiftFrameworksFromObjectiveC/TargetDetails.png&#34; alt=&#34;DetailsNewTarget&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;step-2-make-the-tests-logical&#34;&gt;Step 2 - make the tests logical&lt;/h3&gt;

&lt;p&gt;The idea of Logical Unit Tests is less widely used in the Xcode community, but you can still make sure that your framework tests execute only against your framework code without depending on the application code (no application instance, no app delegate, no views, etc). Even though Apple does not seem to distinguish anymore between application unit tests and logic unit tests, the latter is what we want here: your tests working only with the Swift code in your framework. For this to work you need to make sure that the &lt;code&gt;Host Application&lt;/code&gt; seeting for the &lt;code&gt;ExampleSwiftFrameworkTests&lt;/code&gt; is set to &lt;code&gt;None&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dl.dropboxusercontent.com/u/76613492/tumblr/images/UsingSwiftFrameworksFromObjectiveC/HostApplicationNone.png&#34; alt=&#34;HostApplicationNone&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Logic unit tests cannot be run on the device. They may only run in the simulator.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;step-3-add-example-framework-class&#34;&gt;Step 3 - add example framework class&lt;/h3&gt;

&lt;p&gt;Now inside our example framework, add an example swift class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

class ExampleSwiftFrameworkClass {

    let message: String

    init(withHelloMessage message: String) {
        self.message = message
    }

    func sayHello() -&amp;gt; String {
        return self.message
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tests for this class can be found in the &lt;code&gt;ExampleSwiftFrameworkTests.swift&lt;/code&gt; file in the &lt;code&gt;ExampleSwiftFrameworkTests&lt;/code&gt; target.&lt;/p&gt;

&lt;h3 id=&#34;step-4-referring-to-the-swift-framework-from-the-main-application-target&#34;&gt;Step 4 - referring to the Swift framework from the main application target&lt;/h3&gt;

&lt;p&gt;Now, let&amp;rsquo;s try to reference the &lt;code&gt;ExampleSwiftFrameworkClass&lt;/code&gt; from our main application target - which does not contain any Objective-C code.&lt;/p&gt;

&lt;p&gt;We will be modifying the &lt;code&gt;viewDidLoad&lt;/code&gt; method of the &lt;code&gt;ViewController&lt;/code&gt; class from the main application target. You will quickly realise that Xcode code completion does not work for our class - in this case it right - our class is not visible yet in the main application target.&lt;/p&gt;

&lt;p&gt;To make our class visible you need to import the module it comes from. Add the following line somewhere on the top of your &lt;code&gt;ViewController.m&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@import ExampleSwiftFramework;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may realise that the Xcode&amp;rsquo;s completion already recognized the module, but the our &lt;code&gt;ExampleSwiftFrameworkClass&lt;/code&gt; remains invisible to Xcode. To fix this, we need to do two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Mark your Swift framework class with &lt;code&gt;@objc&lt;/code&gt; annotation, and make it inheritting from &lt;code&gt;NSObject&lt;/code&gt; (if you do not, compiler will tell you that you can&amp;rsquo;t use &lt;code&gt;@objc&lt;/code&gt; annotation otherwise).&lt;/li&gt;
&lt;li&gt;Make sure your class, the constructor, and the method you want to access from another target are &lt;code&gt;public&lt;/code&gt;. The default visibility is &lt;code&gt;internal&lt;/code&gt; which means your class and all its methods are accessible to any other class from the same target. But our framework and our main application are from different targets - that&amp;rsquo;s why we need to use &lt;code&gt;public&lt;/code&gt; for access control.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After the modifications, our &lt;code&gt;ExampleSwiftFrameworkClass&lt;/code&gt; should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@objc
public class ExampleSwiftFrameworkClass : NSObject {

    let message: String

    public init(withHelloMessage message: String) {
        self.message = message
    }

    public func sayHello() -&amp;gt; String {
        return self.message
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you try to run the app or the application tests (not framework tests) you may be surprised seeing that the app crashes with the following log output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dyld: Library not loaded: @rpath/libswiftCore.dylib
  Referenced from:    /Users/usename/Library/Developer/Xcode/DerivedData/UsingSwiftFrameworksFromObjectiveC-befsyfovlmeizgeypzhxolfxbaco/Build/Products/Debug-iphonesimulator/ExampleSwiftFramework.framework/ExampleSwiftFramework
Reason: image not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Xcode is quite intelligent in fixing most of the stuff for us (we will discuss this still in more details below), but there are somethings we have to take care for ourselves.&lt;/p&gt;

&lt;h3 id=&#34;step-5-fixing-the-missing-reference-to-libswiftcore-dylib&#34;&gt;Step 5 - Fixing the missing reference to &lt;code&gt;libswiftCore.dylib&lt;/code&gt;&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;If you are building an app that does not use Swift but embeds content such as a framework that does, Xcode will not include these libraries in your app. As a result, your app will crash upon launching&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The text quoted above comes from the &lt;a href=&#34;https://developer.apple.com/library/ios/qa/qa1881/_index.html&#34;&gt;Technical Q&amp;amp;A QA1881
Embedding Content with Swift in Objective-C&lt;/a&gt;. As resultion it instructs to set &lt;code&gt;Embedded Content Contains Swift Code&lt;/code&gt; build setting to &lt;code&gt;YES&lt;/code&gt; for the target that does not include Swift code itself but depends on a framework that does use Swift. Additionally, it recommends setting the &lt;code&gt;Embedded Content Contains Swift Code&lt;/code&gt; to &lt;code&gt;NO&lt;/code&gt; for the dependent framework target so that we do not get multiple copies of Swift libraries in the app.&lt;/p&gt;

&lt;p&gt;In our example therefore, the only target where we need to set &lt;code&gt;Embedded Content Contains Swift Code&lt;/code&gt; to &lt;code&gt;YES&lt;/code&gt; is the main application target &lt;code&gt;UsingSwiftFrameworksFromObjectiveC&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dl.dropboxusercontent.com/u/76613492/tumblr/images/UsingSwiftFrameworksFromObjectiveC/EmbeddedContent.png&#34; alt=&#34;EmbeddedContentContainsSwiftCode&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;other-settings&#34;&gt;Other settings&lt;/h3&gt;

&lt;p&gt;We mentioned already that Xcode takes care for pretty mych everything. In some cases, however, especially when you deal with a legacy project, it may turn out handy to know what else may require our attention. We summarize the important points below:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Main application target - &lt;code&gt;UsingSwiftFrameworksFromObjectiveC&lt;/code&gt;. We have to make sure that target depends on the framework, the framework is included in the &lt;code&gt;Link Binary With Libraries&lt;/code&gt; build phase, and that the &lt;code&gt;Embed Frameworks&lt;/code&gt; build phase contains the framework with the &lt;code&gt;Destination&lt;/code&gt; set to &lt;code&gt;Frameworks&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dl.dropboxusercontent.com/u/76613492/tumblr/images/UsingSwiftFrameworksFromObjectiveC/MainAppTarget.png&#34; alt=&#34;MainApplicationTargetSettings&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The framework - &lt;code&gt;ExampleSwiftFramework&lt;/code&gt; target. In our case we do not want it to depend on the main application target &lt;code&gt;UsingSwiftFrameworksFromObjectiveC&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dl.dropboxusercontent.com/u/76613492/tumblr/images/UsingSwiftFrameworksFromObjectiveC/ExampleSwiftFramework.png&#34; alt=&#34;ExampleSwiftFrameworkTargetSettings&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ExampleSwiftFrameworkTests&lt;/code&gt; target. It depends on &lt;code&gt;ExampleSwiftFramework&lt;/code&gt; only and includes &lt;code&gt;ExampleSwiftFramework&lt;/code&gt; in the &lt;code&gt;Link Binary With Libraries&lt;/code&gt; build phase:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dl.dropboxusercontent.com/u/76613492/tumblr/images/UsingSwiftFrameworksFromObjectiveC/ExampleSwiftFrameworkTests.png&#34; alt=&#34;ExampleSwiftFrameworkTestsTargetSettings&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;additional-references&#34;&gt;Additional references&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://pewpewthespells.com/blog/swift_and_objc.html&#34;&gt;Technical Q&amp;amp;A QA1881 v2 - Embedding Content with Swift in Objective-C&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html&#34;&gt;Swift and Objective-C in the Same Project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.raywenderlich.com/65964/create-a-framework-for-ios&#34;&gt;How to Create a Framework for iOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@PyBaig/build-your-own-cocoa-touch-frameworks-in-swift-d4ea3d1f9ca3#.aveyhytxy&#34;&gt;Build your own Cocoa Touch Frameworks, in pure Swift&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>module exports vs exports in nodejs</title>
      <link>https://marcinczenko.github.io/post/module-exports-vs-exports-in-node-js/</link>
      <pubDate>Thu, 19 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://marcinczenko.github.io/post/module-exports-vs-exports-in-node-js/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;This post is a summary of the differences between &lt;code&gt;module.exports&lt;/code&gt; and &lt;code&gt;exports&lt;/code&gt; in &lt;code&gt;Node.js&lt;/code&gt; described in the following note:
 &lt;a href=&#34;http://www.hacksparrow.com/node-js-exports-vs-module-exports.html&#34;&gt;Node.js Module – exports vs module.exports&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The article comes from 2011 but then updated in 2014. You may want to take a look at the comments, they add valuable insights. I especially value the one from &lt;strong&gt;Adam Ahmed&lt;/strong&gt;, and I decided to include it below for my own convenience.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;module-exports-vs-exports&#34;&gt;&lt;code&gt;module.exports&lt;/code&gt; vs &lt;code&gt;exports&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;It might help clarify things to show how they are initialized. Essentially before your code runs, there is a code that runs like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var module = {...}; // stuff
var exports = module.exports = {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So both variables initially point to the same empty Object, but of course can be reassigned to any other value instead. So if you reassign the &lt;code&gt;exports&lt;/code&gt; variable, it doesn’t affect &lt;code&gt;module.exports&lt;/code&gt;. Similarly, if you reassign &lt;code&gt;module.exports&lt;/code&gt;, it no longer affects &lt;code&gt;exports&lt;/code&gt;. They will be pointing at different values.
What makes &lt;code&gt;module.exports&lt;/code&gt; the “real deal” is that when someone &lt;code&gt;require()&lt;/code&gt;s your module, &lt;code&gt;require&lt;/code&gt; essential does this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function require(moduleName) {
    var module = getModule(moduleName);
    return module.exports;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It might also help to say that &lt;code&gt;module&lt;/code&gt; is the real deal more than &lt;code&gt;module.exports&lt;/code&gt; is. Take this code for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var truth = module;
var notExports = module.exports;
truth.exports = { genre: ‘Rock’ };
notExports.genre = ‘Blues&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;‘Rock’ will be exported. Since &lt;code&gt;truth&lt;/code&gt; is pointing to &lt;code&gt;module&lt;/code&gt;, it can make lasting changes to the exports that &lt;code&gt;notExports&lt;/code&gt; can’t.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>